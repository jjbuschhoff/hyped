"""Jinja2 Template Data Processor."""
import warnings
from functools import partial
from typing import Annotated, Any, Callable, Iterable

from datasets import ClassLabel, Features, Sequence, Value
from datasets.features.features import FeatureType
from jinja2 import Environment

from hyped.common.lazy import LazyInstance
from hyped.data.flow.processors.base import (
    BaseDataProcessor,
    BaseDataProcessorConfig,
    Sample,
)
from hyped.data.flow.refs.inputs import CheckFeatureEquals, InputRefs
from hyped.data.flow.refs.outputs import (
    LambdaOutputFeature,
    OutputFeature,
    OutputRefs,
)
from hyped.data.flow.refs.ref import FeatureRef


class Jinja2InputRefs(InputRefs):
    """Input features for the Jinja2 Processor.

    In your template, access to the specific input feature values through the `values` variable. Specifically see
    the following example on how to access the respective values:

    .. highlight:: python
    .. code-block:: python

        valA = "The value of A is {{ inputs.A }}."
        featA = "The feature of B is {{ inputs['Name with whitespace'] }}."
    """

    features: Annotated[FeatureRef, CheckFeatureEquals(Features)]
    """The features that are accessable in the template. Access multiple
    features by collecting them. E.g. for
    ```
    features = collect({"some_feat": ...})
    ```
    """


class Jinja2OutputRefs(OutputRefs):
    """Output features generated by Jinja2 Processor."""

    parsed: Annotated[FeatureRef, OutputFeature(Value("string"))]
    """The parsed template."""


class Jinja2Config(BaseDataProcessorConfig):
    """Configuration for the Jinja2 processor."""

    template: str
    """The Jinja2 template to parse."""


class Jinja2(
    BaseDataProcessor[
        Jinja2Config,
        Jinja2InputRefs,
        Jinja2OutputRefs,
    ]
):
    """Jinja2 Processor."""

    def __init__(self, config: Jinja2Config) -> None:
        """Instantiate a new Jinja2 Template Data Processor.

        Arguments:
            config (Jinja2Config):
                config of the data processor
        """
        super(Jinja2, self).__init__(config)
        # setup the jinja environment
        self._setup_jinja_env()

    def _setup_jinja_env(self) -> None:
        """Helper function setting up the jinja environment."""
        # set up the jinja environment
        self.env = Environment(enable_async=True)
        # create template
        self.template = self.env.from_string(self.config.template)

    def __getstate__(self) -> dict[str, Any]:
        """Pickle getstate."""
        state = self.__dict__.copy()
        state.pop("env")
        state.pop("template")
        return state

    def __setstate__(self, state: dict[str, Any]) -> None:
        """Pickle setstate."""
        self.__dict__.update(state)
        self._setup_jinja_env()

    async def process(self, inputs: Sample, index: int, rank: int) -> Sample:
        """Process example.

        Renders the template based on the given example and it's
        features.

        Args:
            inputs (Sample): Input sample containing features for template filling.
            index (int): Index of the sample in the dataset.
            rank (int): Rank of the sample.

        Returns:
            Sample: Output sample containing the parsed template string.
        """
        return Sample(
            parsed=await self.template.render_async(inputs=inputs["features"])
        )
