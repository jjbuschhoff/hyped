"""Jinja2 Template Data Processor."""
import warnings
from functools import partial
from typing import Annotated, Any, Callable, Iterable

from datasets import ClassLabel, Features, Sequence, Value
from datasets.features.features import FeatureType
from jinja2 import Environment, Template

from hyped.common.lazy import LazyInstance
from hyped.data.flow.processors.base import (
    BaseDataProcessor,
    BaseDataProcessorConfig,
    Sample,
)
from hyped.data.flow.refs.inputs import CheckFeatureEquals, InputRefs
from hyped.data.flow.refs.outputs import (
    LambdaOutputFeature,
    OutputFeature,
    OutputRefs,
)
from hyped.data.flow.refs.ref import FeatureRef


class Jinja2InputRefs(InputRefs):
    """Input features for the Jinja2 Processor.

    In your template, access to the specific input feature values through the `values` variable. Specifically see
    the following example on how to access the respective values:

    .. code-block:: python

        valA = "The value of A is {{ inputs.A }}."
        featA = "The feature of B is {{ inputs['Name with whitespace'] }}."
    """

    features: Annotated[FeatureRef, CheckFeatureEquals(Features)]
    """The features that are accessable in the template. Access multiple
    features by collecting them. E.g.

    .. code-block:: python
    
        features = collect(...)
    """


class Jinja2OutputRefs(OutputRefs):
    """Output features generated by Jinja2 Processor."""

    rendered: Annotated[FeatureRef, OutputFeature(Value("string"))]
    """The rendered template."""


class Jinja2Config(BaseDataProcessorConfig):
    """Configuration for the Jinja2 processor."""

    template: str
    """The Jinja2 template to parse."""


def _setup_jinja_env(template_str: str) -> Template:
    """Helper function setting up the jinja environment."""
    # set up the jinja environment
    env = Environment(enable_async=True)
    # create template
    return env.from_string(template_str)


class Jinja2(
    BaseDataProcessor[
        Jinja2Config,
        Jinja2InputRefs,
        Jinja2OutputRefs,
    ]
):
    """Jinja2 Processor."""

    def __init__(self, config: None | Jinja2Config = None, **kwargs) -> None:
        """Instantiate a new Jinja2 Template Data Processor.

        Args:
            config (Jinja2Config): Config of the Jinja2 processor.
            **kwargs: Additional keyword arguments that update the provided configuration
                or create a new configuration if none is provided.
        """
        super(Jinja2, self).__init__(config, **kwargs)
        self.template = LazyInstance(
            partial(_setup_jinja_env, self.config.template)
        )

    async def process(self, inputs: Sample, index: int, rank: int) -> Sample:
        """Process example.

        Renders the template based on the given example and it's
        features.

        Args:
            inputs (Sample): Input sample containing features for template filling.
            index (int): Index of the sample in the dataset.
            rank (int): Rank of the sample.

        Returns:
            Sample: Output sample containing the rendered template string.
        """
        return Sample(
            rendered=await self.template.render_async(
                inputs=inputs["features"]
            )
        )
